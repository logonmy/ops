#!/usr/bin/python
# -*- coding:utf8 -*-

server_url = "http://127.0.0.1:8000"
script_path = '/tmp/script'
complete_cache_file = '/tmp/index_complete_cache_file.json'
word_completer_cache_file = '/tmp/word_completer_cache_file.json'

import os, urllib2, urllib
import subprocess
import datetime
import re
import logging
import sys
import struct
import tempfile
import threading
import getopt
import socket
import time
from logging.handlers import RotatingFileHandler
import requests
import json

from prompt_toolkit import prompt, AbortAction
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.contrib.completers import WordCompleter

from pygments.style import Style
from pygments.token import Token
from pygments.styles.default import DefaultStyle
from pygments.lexer import RegexLexer
from pygments.lexer import words
from pygments.token import Keyword, Literal, Name, Operator, Text

client_log_filename = tempfile.gettempdir() + os.path.sep + 'cli.log'
logger = logging.getLogger()
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)-25s %(module)s:%(lineno)d  %(levelname)-8s %(message)s',
    filename=client_log_filename,
    filemode='a')
logger.addHandler(RotatingFileHandler(filename=client_log_filename,
                                      maxBytes=100 * 1024 * 1024,
                                      backupCount=3))


class CompletionIndex:
    def __init__(self, cache_file=complete_cache_file):
        self.cache_file = cache_file
        self.commands = []
        self.subcommands = []
        self.global_opts = []
        self.args_opts = set()

    def load_completions(self):
        try:
            r = requests.post(server_url + '/complete/loadindex')
            text = json.loads(r.text)
            contents = json.dumps(text)
            f = open(self.cache_file, 'wb+')
            f.write(contents)
            f.close()
        except Exception as e:
            logger.info(e)
            f = open(self.cache_file, 'rb')
            contents = f.read()
            f.close()
        contents_json = json.loads(contents)
        self.commands = contents_json.get('commands')
        self.subcommands = contents_json.get('subcommands')
        self.global_opts = contents_json.get('global_opts')
        self.args_opts = contents_json.get('args_opts')
        return contents


class ShellLexer(RegexLexer):
    completion_index = CompletionIndex()
    completion_index.load_completions()
    tokens = {
        'root': [
            # ec2, s3, elb...
            (words(
                tuple(completion_index.commands),
                prefix=r'\b',
                suffix=r'\b'), Literal.String),
            # describe-instances
            (words(
                tuple(completion_index.subcommands),
                prefix=r'\b',
                suffix=r'\b'), Name.Class),
            # --instance-ids
            (words(
                tuple(list(completion_index.args_opts)),
                prefix=r'',
                suffix=r'\b'), Keyword.Declaration),
            # --profile
            (words(
                tuple(completion_index.global_opts),
                prefix=r'',
                suffix=r'\b'), Operator.Word),
            # Everything else
            (r'.*\n', Text),
        ]
    }


class DocumentStyle(Style):
    styles = {
        Token.Menu.Completions.Completion.Current: 'bg:#00aaaa #000000',
        Token.Menu.Completions.Completion: 'bg:#008888 #ffffff',
        Token.Menu.Completions.ProgressButton: 'bg:#003333',
        Token.Menu.Completions.ProgressBar: 'bg:#00aaaa',
    }
    styles.update(DefaultStyle.styles)


class Command(object):
    def __init__(self, cmd):
        self.cmd = cmd
        self.process = None
        self.uuid = str(datetime.datetime.now()).replace(' ', '').replace(
            ':', '').replace('-', '').replace('.', '')
        self.result = open(tempfile.gettempdir() + os.path.sep + self.uuid,
                           'a+')

    def run(self, timeout=30):
        def target():
            logger.info(self.cmd)
            self.process = subprocess.Popen(self.cmd,
                                            shell=True,
                                            stdout=self.result,
                                            stderr=self.result)
            self.process.communicate()

        thread = threading.Thread(target=target)
        thread.start()
        thread.join(timeout)
        if thread.is_alive():
            logger.info(self.cmd)
            self.process.terminate()
            thread.join()
            util = Common()
            util.url_fetch(server_url + '/slowlog/log', {'cmd': self.cmd,
                                                         'ip':
                                                         util.get_one_ip()})
            return self.cmd
        result = open(tempfile.gettempdir() + os.path.sep + self.uuid,
                      'r').read()
        os.unlink(tempfile.gettempdir() + os.path.sep + self.uuid)
        return result


class Common(object):
    def urlencode(self, str):
        reprStr = repr(str).replace(r'\x', '%')
        return reprStr[1:-1]

    def download(self, filename):
        data = {'file': filename}
        data = urllib.urlencode(data)
        http_url = '%s/file/download?%s' % (server_url, data)
        try:
            conn = urllib2.urlopen(http_url)
            raw = conn.read()
            filename = os.path.basename(filename)
            if raw != '':
                f = open(filename, 'wb')
                f.write(raw)
                f.close()
            else:
                print 'file not exists,please upload it'
        except Exception, e:
            logger.error(e)
            print e

    def upload(self, filepath):
        files = {'file': open(filepath, 'rb')}
        headers = {'User-Agent': 'Mozilla/5.0',
                   'Referer': 'http://www.taobao.com/'}
        http_url = '%s/file/upload' % server_url
        try:
            r = requests.post(http_url, files=files, headers=headers)
            print r.text
        except Exception, e:
            logger.error(e)
            print e

    def ip2int(self, server_ip):
        return struct.unpack("!I", socket.inet_aton(server_ip))[0]

    def int2ip(self, interger):
        return socket.inet_ntoa(struct.pack("!I", interger))

    def request_id(self, uid, server_ip):
        ip2int = self.ip2int(server_ip)
        now_time = time.time()
        request_id = str(ip2int) + str(now_time) + str(uid)
        return request_id.replace('.', '')

    def url_fetch(self, url, data=None, timeout=30):
        html = ''
        try:
            uid = os.getuid()
            server_ip = self.get_one_ip()
            headers = {
                'User-Agent':
                'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6',
                'Login-user': os.getlogin(),
                'Login-uid': uid,
                'Login-gid': os.getgid(),
                'Exec-path': os.getcwd(),
                'Server-ip': server_ip,
                'Hostname': self.get_hostname(),
                'request-id': self.request_id(uid, server_ip)
            }

            if data != None:
                if data.has_key('f') and os.path.isfile(data.get('f')):
                    files = files = {'f': open(data.get('f'), 'rb')}
                    del data['f']
                    r = requests.post(url,
                                      files=files,
                                      headers=headers,
                                      data=data)
                else:
                    r = requests.post(url, headers=headers, data=data)
            else:
                r = requests.post(url, headers=headers)

            html = r.text
            charset = re.compile(
                r'<meta[^>]*charset=[\'\"]*?([a-z0-8\-]+)[\'\"]?[^>]*?>',
                re.IGNORECASE).findall(html)
            if len(charset) > 0:
                if charset[0] == 'gb2312':
                    charset[0] = 'gbk'
                html = unicode(html, charset[0])
        except Exception as e:
            if hasattr(e, 'msg'):
                print(e.msg)
            else:
                print e

            logger.error(e)
        return html

    def parse_argv(self, argv):
        data = {}
        long_args = []
        short_args = []
        for v in argv:
            if v.startswith('--'):
                long_args.append(v.replace('--', '') + "=")
            elif v.startswith('-'):
                short_args.append(v.replace('-', ''))
        opts = getopt.getopt(argv, ":".join(short_args) + ":", long_args)
        for opt in opts[0]:
            data[opt[0].replace('-', '')] = opt[1]
        if len(data) > 0:
            return data
        else:
            return argv

    def execute(self, cmd):
        try:
            return os.popen(cmd).read()
        except Exception as err:
            logger.error(err)
            return ""

    def get_one_ip(self):
        hostname = self.get_hostname()
        ret = socket.gethostbyname(hostname)
        return ret.strip()

    def get_hostname(self):
        os_name = os.name
        host_name = None
        if os_name == 'nt':
            host_name = os.getenv('computername')
        elif os_name == 'posix':
            host = os.popen('hostname')
            try:
                host_name = host.read().strip()
            finally:
                host.close()
        return host_name

    def command_args(self, args):
        if isinstance(args, list) or isinstance(args, tuple):
            return '"%s"' % '" "'.join(args)
        else:
            return str(args)


class Cli():
    def __init__(self):
        self.entry = server_url + "/%s"
        self.util = Common()

    def download(self, args):
        self.util.download(args[0])

    def upload(self, args):
        self.util.upload(args[0])

    def listfile(self, args):
        ret = self.util.url_fetch(self.entry % 'file/listfile')
        print(ret)

    def help(self, args):
        ret = self.util.url_fetch(self.entry % 'help/list')
        print(ret)

    def default(self, cmd, args):
        argv = self.util.parse_argv(args[1:])
        if isinstance(argv, list):
            argv = {}
        ret = self.util.url_fetch(self.entry % cmd, argv)
        print(ret)

    def shell(self, args):
        if len(args) < 1:
            print('ERROR: param is not enough')
            sys.exit(0)
        path = script_path
        if not os.path.exists(path):
            os.makedis(path, 0777)

        fn = path + os.path.sep + args[0]
        src = ''
        is_python = False
        if not os.path.exists(fn) or os.stat(fn).st_mtime < (
                time.time() - 10 * 60):
            self.download(args)
            self.util.execute("mv ./%s %s" % (args[0], fn))

        src = open(fn, 'r').read()

        lines = re.split(r'\n', src)
        for line in lines:
            if line.strip() != '':
                break
        if line.find('python') > 0:
            is_python = True
        if is_python:
            cmd = Command('/usr/bin/python %s %s' %
                          (fn, self.util.command_args(args[1:])))
            result = cmd.run(60 * 60 * 24)
        else:
            cmd = Command('/bin/bash %s %s' %
                          (fn, self.util.command_args(args[1:])))
            result = cmd.run(60 * 60 * 24)
        print(result)


def main():
    history = InMemoryHistory()
    try:
        r = requests.post(server_url + '/complete/word')
        f = open(word_completer_cache_file, 'wb+')
        word_completer = r.text
        f.write(word_completer)
        f.close()
    except Exception as e:
        logger.info(e)
        f = open(word_completer_cache_file, 'rb')
        word_completer = f.read()
        f.close()
    wordcompleter = WordCompleter(word_completer, ignore_case=True)
    cli = Cli()
    while True:
        try:
            text = prompt('> ',
                          lexer=ShellLexer,
                          completer=wordcompleter,
                          style=DocumentStyle,
                          history=history,
                          on_abort=AbortAction.RETRY)
        except EOFError as e:
            logger.info(e)

        if len(sys.argv) < 2:
            cli.help(sys.argv)
        else:
            ctl = sys.argv[1]
            if len(sys.argv) > 2:
                cmd = sys.argv[2]
            else:
                cmd = 'help'
            if hasattr(cli, ctl):
                getattr(cli, ctl)(sys.argv[2:])
            else:
                cli.default(ctl + '/' + cmd, sys.argv[2:])


if __name__ == '__main__':
    main()
